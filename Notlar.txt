Microsoft.EntityFrameworkCore
Microsoft.EntityFrameworkCore.Design
Microsoft.EntityFrameworkCore.SqlServer
Microsoft.EntityFrameworkCore.Tools
Yukarýdaki paketlerin DataAccessLayer ve UI Katmanýna Kurulmasý gerekmektedir kurulu deðilse migration iþlemleri yapýlamaz

add-migration mig01 mig01 adýnda migration oluþturur
update-database oluþturulan migrationu veri tabanýna yansýtýr.
List ile ICollection arasýndaki fark:
ICollection" bir interface iken "List" ise bir class týr. "ICollection", aralarýnda "List" de bulunan ve "ICollection" interfaceini implemente eden herhangi bir classý veya bu classlardan türetilen herhangi bir classý alabilirken, "List" sadece kendini ve List den türetilen sýnýflarý kabul eder.

DRY (Don’t Repeat Yourself) prensibine göre kod içindeki her parçacýðýn kendine özelleþtirilmiþ bir yapýsý, görevi olmalýdýr.
Aksi halde bir deðiþiklik yapýlmasý gerektiðinde o parçadan etkilenen diðer parçalarda da deðiþiklik yapýlmasý gerekir ki bu da çoðu zaman karmaþýklýða sebep olur. Kod tekrarýndan kaçýnýlmalý, tekrarlamalar soyutlama yolu ile aþýlmalýdýr.

Context c= new Context ifadesi Class genelinde tanýmlanýr ve tüm class içerisinde kullanýlýr. 
using var = new Context ifadesi ise sadece yazýlý olan method içerisinde kullanýlýr ve her method için tanýmlanmak zorundadýr.

Bir sýnýfýn içerisinde kalýtsal yoldan bir interface miras alýnýyorsa o sýnýfa o interfaceyi imlemente etmek gerekir.
CTRL+Shift+W kýsayoluyla "View in Browser" çalýþmakta ya da Views klasörü altýnda ilgili sayfaya sað click yaparakta "View in Browser" 'ý açabilirsiniz. Visual Studio 2022 çalýþma mantýðý bu þekilde.

1.Görev: Projenin Githupa yüklenmesi :Tamam.

Ödev 
Eager Loading: nesneyi ihtiyaç anýndan hemen önce oluþturur ve bekletir. Linq sorgusu çalýþtýrýldýðýnda verilerin tamamýný yükler ve hafýzaya alýr. Daha ucuz maliyetlidir.
Lazy Loading : Bu yöntemde veriler sorguya baðlý olarak çekilir ancak veri setinin içindeki tüm datalarý yüklemek yerine verilerin çaðrýldýkça otomatik yüklenmesi söz konusudur. Daha pahalý iþlemdir.

öncelikle interface in default durumu public deðil. classlarýn da private deðil. hepsi internaldýr. internal tipinde bir interface'e ayný katman içinden eriþirsiniz fakat farklý katmandan eriþemezsiniz. baþýna public yazmazsa controller katmanýndan bu interfacelere eriþemez. default hali public olan þey ise interfacein kendisi deðil metodlarý (imzalarý) dýr.

Ödev
MVC’nin önceki sürümlerinde birden fazla alanda kullanmak istediðimiz bileþenleri genellikle Partial View olarak tasarlar ve [ChildActionOnly] attribute ile birlikte tek baþlarýna çaðrýlmalarýný engellerdik. Bu yapý bizim için büyük kolaylýk saðlardý. Asp.Net Core ile birlikte [ChildActionOnly] attribute kullanýmý kaldýrýlmýþ ve yeni ViewComponent yapýsý geliþtirilmiþtir. ViewComponentler dýþarýdan Http istek ile doðrudan ulaþýlamazlar. Ve view components'lar partial view'e  çok benzer, ancak partial view'e kýyasla çok daha güçlüdür. view components'lar model baðlama kullanmaz. Ancak, yalnýzca onu çaðýrdýðýmýzda saðlanan verilerle çalýþýr. partial view  gibi, view componentsi de controller'lara baðlý deðildir. Bileþenin modelini ve ustura biçimlendirme görünüm sayfasýný geliþtirmek için mantýðý uygulamak için kendi sýnýfýna sahiptir. En önemli þey, View Components'ýn baðýmlýlýk enjeksiyonunu kullanabilmesidir, bu da onlarý çok güçlü ve test edilebilir kýlar.

NOT: Ekleme iþlemi yapýlýrken,httpget ve httppost attributlerinin tanýmlandýðý metotlarýn isimleri ayný olmak zorundadýr.

HttpGet:Sayfa yklenince
HttPost : Sayfada buton tetiklenince

Mesela HttpGet Attribute komutu sayfada kategorize veya benzeri iþlemler kullanýrken sayfa yüklendiði anda listelenmesi istenen niteliklerde kullanýlabilir.

Authentication="kimlik doðrulamasý"
Authorization="kimlik yetkikendirme"
Claim=""kullanýcý hakkýnda bilgiler tutan yapýlar diyebiliriz."
Kýsaca Claim anlatmamýz gerekirse Örneðin:Youtobe'a giriþ yaptýk ve Youtobe bize izleyici rolü tanýmladý,bu tanýmlama ile beraber istediðmiz video'yu izleyebiliyoruz.Ama diyelim ki yaþýmýz 18'den küçük ve bazý korku gerilim videolarý +18 sýnýr konulmasý gerekiyor,Ýþte burada yaþ aralýðýný ölçebilmek için ilgili kullanýcýlarýn yaþ deðerlerinin claim olarak atanmasý saðlanmalý ve claim bazlý bir yetkilendirme yapýlmalýdýr.

IsRequired: ilgili alanýn zorunluluðunu ifade eder. Bununla beraber IsOptional  opsiyonel olduðunu da belirtebiliriz.
OnDelete yöntemi içinde 3 paremetre; (Silinme Durumunda)
Cascade: Baðýmlý olanlar siliniyor
Restrict: Baðýmlý olanlar etkilenmiyor
SetNull: Deðer NULL olarak deðiþtiriliyor.


Arkadaþlar gelen mesajlarda 2 dakika önce, 2 saat önce vb mesajlarýný görmek istiyorsanýz aþaðýdaki 3 adýmý yapabilirsiniz.

1. Adým -> Model sýnýfa bir class oluþturup içerisine: 

    public static class Time
        {
        public static string Zaman(this DateTime date)
        {
            //Bugünden gelen tarihinin farkýný alýyorum
            var timeSpan = DateTime.Now - date;
            //60 saniyeden küçükse 
            if (timeSpan <= TimeSpan.FromSeconds(60))
                return string.Format("{0} saniye önce", timeSpan.Seconds);
            //60 dakikadan küçükse
            else if (timeSpan <= TimeSpan.FromMinutes(60))
                return timeSpan.Minutes > 1 ? string.Format("{0} dakika önce", timeSpan.Minutes) : "yaklaþýk bir dakika önce";
            //24 saatten küçükse
            else if (timeSpan <= TimeSpan.FromHours(24))
                return timeSpan.Hours > 1 ? String.Format("{0} saat önce", timeSpan.Hours) : "yaklaþýk bir saat önce";
            //30 günden küçükse
            else if (timeSpan <= TimeSpan.FromDays(30))
                return timeSpan.Days > 1 ? String.Format("{0} gün önce", timeSpan.Days) : "dün";
            //365 günden küçükse
            else if (timeSpan <= TimeSpan.FromDays(365))
                return timeSpan.Days > 30 ? String.Format("{0} ay önce", timeSpan.Days / 30) : "yaklaþýk bir ay önce";
            //Yýl 
            return timeSpan.Days > 365 ? String.Format("{0} yýl önce", timeSpan.Days / 365) : "yaklaþýk bir yýl önce";
        }
    }

2. Adým -> Daha sonra kullanmak istediðimiz yerde tanýmlýyoruz.

@using CoreProje.Models

3. Adým -> Zaman belirten item varsa .Zaman() fonksiyonunu ekliyoruz.

Örneðin: @item.MessageDate.Zaman()